<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>ブロック崩し - 爆弾改良版</title>
    <style>
        body { padding: 0; margin: 0; overflow: hidden; background-color: #333; font-family: sans-serif; }
        canvas { background-color: #eee; display: block; margin: 20px auto; box-shadow: 0 0 20px rgba(0,0,0,0.5); cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="main-canvas" width="400" height="600"></canvas>

    <script>
        // --- 音響エンジン ---
        const Sound = {
            ctx: null,
            init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            play(freq, type = 'sine', duration = 0.1, volume = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                osc.connect(gain); gain.connect(this.ctx.destination);
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            },
            play1UP() {
                const notes = [1567.98, 1318.51, 2093.00, 1760.00, 2349.32];
                notes.forEach((f, i) => setTimeout(() => this.play(f, 'sine', 0.4, 0.15), i * 60));
            },
            playExplosion() {
                this.play(200, 'sawtooth', 0.4, 0.2);
                this.play(100, 'square', 0.3, 0.1);
            }
        };

        // --- パーティクルクラス ---
        class Particle {
            constructor(x, y, color, isTrail = false) {
                this.x = x; this.y = y; this.color = color;
                this.isTrail = isTrail;
                this.life = 1.0;
                if (isTrail) {
                    this.vx = 0; this.vy = 0;
                    this.decay = 0.06;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 4 + 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.decay = Math.random() * 0.02 + 0.015;
                }
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (!this.isTrail) this.vy += 0.1;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.fillStyle = `hsla(${this.color.h}, ${this.color.s}%, ${this.color.l}%, ${this.life})`;
                const size = this.isTrail ? 7 : 3;
                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
            }
        }

        // --- アイテムクラス ---
        class Item {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; 
                this.radius = 12; // 少し大きくして当たりやすく
                this.isAlive = true;
            }
            update() { 
                if (this.type !== 'bomb') {
                    this.y += 2.5; 
                }
                if (this.y > 600) this.isAlive = false; 
            }
            // 爆発処理を共通化
            explode() {
                this.isAlive = false;
                Sound.playExplosion();
                blocks.forEach(b => {
                    let d = Math.sqrt((b.x - this.x)**2 + (b.y - this.y)**2);
                    if (d < 80) { // 爆風範囲
                        b.hp -= 10;
                        if (b.hp <= 0) {
                            score += 100;
                            for(let i=0; i<10; i++) particles.push(new Particle(b.x, b.y, b.baseColor));
                        }
                    }
                });
                for(let i=0; i<40; i++) particles.push(new Particle(this.x, this.y, {h: Math.random()*40+10, s: 100, l: 50}));
            }
            draw(ctx) {
                let color;
                switch(this.type) {
                    case 'bomb': color = '#000'; break;
                    case 'multi': color = '#f0f'; break;
                    case 'wide': color = '#0f0'; break;
                    case 'pierce': color = '#f80'; break;
                }
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
                
                if (this.type === 'bomb') {
                    ctx.fillStyle = '#ff0'; ctx.beginPath(); 
                    ctx.arc(this.x + 6, this.y - 6, 4, 0, Math.PI*2); ctx.fill();
                }
                
                ctx.fillStyle = 'white'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
                ctx.fillText(this.type[0].toUpperCase(), this.x, this.y + 4);
            }
        }

        class Paddle {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 80; this.height = 12; this.speed = 6.6; 
            }
            move(keyStatus) {
                if (keyStatus.ArrowLeft) this.x -= this.speed;
                if (keyStatus.ArrowRight) this.x += this.speed;
            }
            changeWidth(amount, maxWidth) {
                this.width += amount;
                this.width = Math.max(20, Math.min(this.width, maxWidth));
            }
            clamp(rect) {
                if (this.x - this.width / 2 < rect.left) this.x = rect.left + this.width / 2;
                else if (this.x + this.width / 2 > rect.right) this.x = rect.right - this.width / 2;
            }
            draw(ctx) {
                let bL = this.x - this.width / 2, bT = this.y - this.height / 2;
                let grad = ctx.createLinearGradient(bL, bT, bL, bT + this.height);
                grad.addColorStop(0, '#88aaff'); grad.addColorStop(0.5, '#4466ff'); grad.addColorStop(1, '#2233aa');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.roundRect(bL, bT, this.width, this.height, 4); ctx.fill();
            }
        }

        class Ball {
            constructor(x, y, vx, vy) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.radius = 6; this.isAlive = true;
                this.isPierce = false; this.pierceTimer = 0;
            }
            move(steps) { this.x += this.vx / steps; this.y += this.vy / steps; }
            speedUp(multiplier) { this.vx *= multiplier; this.vy *= multiplier; }
            bounceWall(rect) {
                let hit = false;
                if (this.x - this.radius < rect.left) { this.x = rect.left + this.radius; this.vx = -this.vx; hit = true; }
                else if (this.x + this.radius > rect.right) { this.x = rect.right - this.radius; this.vx = -this.vx; hit = true; }
                if (this.y - this.radius < rect.top) { this.y = rect.top + this.radius; this.vy = -this.vy; hit = true; }
                if (hit) Sound.play(400, 'square', 0.05, 0.05);
                if (this.y - this.radius > rect.bottom) { this.isAlive = false; Sound.play(150, 'sawtooth', 0.3, 0.1); }
            }
            bouncePaddle(paddle) {
                if (this.x < paddle.x - paddle.width / 2 || this.x > paddle.x + paddle.width / 2 ||
                    this.y + this.radius < paddle.y - paddle.height / 2 || this.y - this.radius > paddle.y + paddle.height / 2) return;
                if (this.vy > 0) {
                    let speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    this.y = paddle.y - paddle.height / 2 - this.radius;
                    this.vy = -this.vy;
                    let hitPos = (this.x - paddle.x) / (paddle.width / 2);
                    this.vx = hitPos * (speed * 0.8);
                    Sound.play(600, 'sine', 0.1, 0.1); 
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.isPierce ? '#ff8800' : '#ff1111';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(this.x - 2, this.y - 2, 2, 0, Math.PI * 2); ctx.fill();
            }
        }

        class Block {
            constructor(x, y, hp) {
                this.x = x; this.y = y; this.width = 45; this.height = 20;
                this.hp = hp; this.isAlive = true;
                this.baseColor = { h: 0, s: 0, l: 0 };
            }
            updateColor() {
                if (this.hp >= 10) this.baseColor = { h: 50, s: 100, l: 50 };
                else if (this.hp >= 5) this.baseColor = { h: 0, s: 0, l: 20 };
                else if (this.hp >= 3) this.baseColor = { h: 0, s: 80, l: 60 };
                else if (this.hp == 2) this.baseColor = { h: 40, s: 90, l: 60 };
                else this.baseColor = { h: 120, s: 70, l: 60 };
            }
            draw(ctx) {
                this.updateColor();
                let bL = this.x - this.width / 2, bT = this.y - this.height / 2;
                let grad = ctx.createLinearGradient(bL, bT, bL, bT + this.height);
                grad.addColorStop(0, `hsl(${this.baseColor.h}, ${this.baseColor.s}%, ${this.baseColor.l + 20}%)`);
                grad.addColorStop(0.5, `hsl(${this.baseColor.h}, ${this.baseColor.s}%, ${this.baseColor.l}%)`);
                grad.addColorStop(1, `hsl(${this.baseColor.h}, ${this.baseColor.s}%, ${this.baseColor.l - 20}%)`);
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.roundRect(bL, bT, this.width, this.height, 5); ctx.fill();
            }
            checkCollision(ball) {
                if (!this.isAlive) return false;
                let bL = this.x - this.width / 2, bR = this.x + this.width / 2;
                let bT = this.y - this.height / 2, bB = this.y + this.height / 2;
                if (ball.x + ball.radius < bL || ball.x - ball.radius > bR || 
                    ball.y + ball.radius < bT || ball.y - ball.radius > bB) return false;
                
                if (!ball.isPierce) {
                    let overlapL = (ball.x + ball.radius) - bL, overlapR = bR - (ball.x - ball.radius);
                    let overlapT = (ball.y + ball.radius) - bT, overlapB = bB - (ball.y - ball.radius);
                    let minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);
                    if (minOverlap === overlapL) { ball.vx = -Math.abs(ball.vx); ball.x = bL - ball.radius; }
                    else if (minOverlap === overlapR) { ball.vx = Math.abs(ball.vx); ball.x = bR + ball.radius; }
                    else if (minOverlap === overlapT) { ball.vy = -Math.abs(ball.vy); ball.y = bT - ball.radius; }
                    else { ball.vy = Math.abs(ball.vy); ball.y = bB + ball.radius; }
                }
                
                score += 100; this.hp--; 
                if (this.hp <= 0) { 
                    this.isAlive = false; 
                    Sound.play(1000, 'sine', 0.1, 0.15); 
                    for(let i=0; i<15; i++) particles.push(new Particle(this.x, this.y, this.baseColor));
                    // アイテムドロップ率 (7%)
                    if (Math.random() < 0.07) {
                        const types = ['multi', 'wide', 'pierce', 'bomb'];
                        items.push(new Item(this.x, this.y, types[Math.floor(Math.random()*types.length)]));
                    }
                } else { Sound.play(800, 'sine', 0.05, 0.1); }
                return true;
            }
        }

        let canvas, ctx, screenArea, paddle, balls = [], blocks = [], particles = [], items = [];
        let gameState = 'ready', score = 0, lives = 3, nextSpeedUpScore = 500, lastExtraLifeScore = 0;
        let speedUpTimer = 0, level = 1, currentBallVx = 3, currentBallVy = -4;
        let keyStatus = { ArrowLeft: false, ArrowRight: false };

        function createBlocks() {
            blocks = [];
            if (level === 1) { for (let r = 0; r < 6; r++) for (let c = 0; c < 8; c++) blocks.push(new Block(25 + c * 50, 60 + r * 25, 3 - Math.floor(r / 2))); }
            else if (level === 2) { [{x: 50, y: 80}, {x: 350, y: 80}, {x: 100, y: 130}, {x: 300, y: 130}, {x: 150, y: 180}, {x: 250, y: 180}, {x: 200, y: 230}].forEach(p => blocks.push(new Block(p.x, p.y, 5))); }
            else if (level === 3) {
                const layout = [[0, 5, 1, 0, 0, 1, 5, 0], [0, 5, 5, 3, 3, 5, 5, 0], [0, 3, 3, 3, 3, 3, 3, 0], [3, 3, 15, 15, 15, 15, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3], [0, 2, 0, 3, 3, 0, 2, 0], [0, 0, 2, 0, 0, 2, 0, 0]];
                for (let r = 0; r < layout.length; r++) for (let c = 0; c < layout[r].length; c++) if (layout[r][c] > 0) blocks.push(new Block(25 + c * 50, 80 + r * 25, layout[r][c]));
            }
        }

        function resetBall() {
            let sm = (level === 3) ? 1.2 : 1.0;
            balls = [new Ball(canvas.width / 2, canvas.height - 100, currentBallVx * sm, -Math.abs(currentBallVy) * sm)];
            paddle.x = canvas.width / 2; paddle.width = 80; items = [];
        }

        function startGame() {
            Sound.init();
            gameState = 'playing'; score = 0; lives = 3; level = 1; lastExtraLifeScore = 0;
            currentBallVx = 3; currentBallVy = -4; nextSpeedUpScore = 500;
            paddle = new Paddle(canvas.width / 2, canvas.height - 40);
            particles = []; items = []; createBlocks(); resetBall();
        }

        function mainLoop() {
            ctx.fillStyle = 'rgb(230, 230, 250)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'playing') {
                paddle.move(keyStatus); paddle.clamp(screenArea);

                balls.forEach(ball => {
                    const rainbowHue = (Date.now() / 5) % 360; 
                    const trailHue = ball.isPierce ? (Math.sin(Date.now()/50)*30 + 30) : rainbowHue;
                    particles.push(new Particle(ball.x, ball.y, {h: trailHue, s: 100, l: 70}, true));

                    const subSteps = 4;
                    for (let i = 0; i < subSteps; i++) {
                        ball.move(subSteps); ball.bounceWall(screenArea); ball.bouncePaddle(paddle);
                        
                        // 爆弾（アイテム）との衝突判定を追加
                        for (let it of items) {
                            if (it.type === 'bomb' && it.isAlive) {
                                let d = Math.sqrt((ball.x - it.x)**2 + (ball.y - it.y)**2);
                                if (d < ball.radius + it.radius) {
                                    it.explode();
                                }
                            }
                        }

                        for (let b of blocks) {
                            if (b.checkCollision(ball)) {
                                if (score >= lastExtraLifeScore + 5000) { lives++; lastExtraLifeScore += 5000; Sound.play1UP(); }
                                if (score >= nextSpeedUpScore) { 
                                    ball.speedUp(1.05); nextSpeedUpScore += 500; speedUpTimer = 60; 
                                    currentBallVx = ball.vx; currentBallVy = ball.vy; 
                                    Sound.play(1200, 'sawtooth', 0.1, 0.05); 
                                }
                                break; 
                            }
                        }
                    }
                    if (ball.isPierce) { ball.pierceTimer--; if (ball.pierceTimer <= 0) ball.isPierce = false; }
                });

                balls = balls.filter(b => b.isAlive);
                if (balls.length === 0) { lives--; gameState = (lives <= 0) ? 'gameOver' : 'out'; }

                items.forEach(it => {
                    it.update();
                    // パドルとの接触判定
                    if (it.isAlive && Math.abs(it.y - paddle.y) < 20 && Math.abs(it.x - paddle.x) < paddle.width/2 + 5) {
                        if (it.type === 'bomb') {
                            it.explode();
                        } else {
                            it.isAlive = false;
                            Sound.play1UP();
                            if (it.type === 'multi') {
                                balls.push(new Ball(paddle.x, paddle.y-20, -3, -4), new Ball(paddle.x, paddle.y-20, 3, -4));
                            } else if (it.type === 'wide') {
                                paddle.width = 140; setTimeout(() => paddle.width = 80, 8000);
                            } else if (it.type === 'pierce') {
                                balls.forEach(b => { b.isPierce = true; b.pierceTimer = 400; });
                            }
                        }
                    }
                });
                items = items.filter(it => it.isAlive);
                particles.forEach(p => p.update());
                particles = particles.filter(p => p.life > 0);
                blocks = blocks.filter(b => b.isAlive);
                if (blocks.length === 0) { gameState = (level < 3) ? 'levelClear' : 'gameClear'; Sound.play(1000, 'sine', 0.5); }
            }

            blocks.forEach(b => b.draw(ctx));
            particles.forEach(p => p.draw(ctx));
            items.forEach(it => it.draw(ctx));
            if (paddle) paddle.draw(ctx);
            balls.forEach(b => b.draw(ctx));

            ctx.fillStyle = 'black'; ctx.font = '20px sans-serif'; ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${score}`, 10, 30);
            ctx.fillText(`残機: ${lives}`, 280, 30);
            ctx.fillText(`LEVEL: ${level}`, 10, canvas.height - 10);
            if (speedUpTimer > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${speedUpTimer/60})`; ctx.textAlign = 'center'; ctx.fillText('SPEED UP!!', canvas.width/2, 150); speedUpTimer--; }
            if (gameState !== 'playing') drawOverlay();
            requestAnimationFrame(mainLoop);
        }

        function drawOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; ctx.textAlign = 'center';
            let m = "", s = "";
            if (gameState === 'ready') { m = "ブロック崩し"; s = "Enter またはクリックでスタート"; }
            else if (gameState === 'paused') { m = "PAUSE"; s = "Space またはクリックで再開"; }
            else if (gameState === 'out') { m = "OUT!"; s = "Space またはクリックでリスタート"; }
            else if (gameState === 'levelClear') { m = "CLEAR!"; s = "Space またはクリックで次のレベル"; }
            else if (gameState === 'gameOver') { m = "GAME OVER"; s = "Enter またはクリックで最初から"; }
            else if (gameState === 'gameClear') { m = "ALL CLEAR!"; s = "Enter またはクリックで最初から"; }
            ctx.font = 'bold 30px sans-serif'; ctx.fillText(m, canvas.width/2, canvas.height/2);
            ctx.font = '18px sans-serif'; ctx.fillText(s, canvas.width/2, canvas.height/2 + 40);
        }

        function handleInteraction() {
            Sound.init();
            if (['ready', 'gameOver', 'gameClear'].includes(gameState)) startGame();
            else if (gameState === 'paused') gameState = 'playing';
            else if (gameState === 'out') { gameState = 'playing'; resetBall(); }
            else if (gameState === 'levelClear') { level++; createBlocks(); resetBall(); gameState = 'playing'; }
        }

        window.addEventListener('keydown', e => {
            if (['1', '2', '3'].includes(e.key)) {
                level = parseInt(e.key); createBlocks(); resetBall();
                if (gameState === 'paused' || gameState === 'ready') gameState = 'playing';
            }
            if (gameState === 'playing' || gameState === 'paused') {
                if (e.key === '+' || e.key === ';') { lives++; Sound.play1UP(); }
                if (e.key === '-' || e.key === '=') { balls.forEach(b => b.speedUp(0.95)); }
                if (e.key === 'w' || e.key === 'W') { paddle.changeWidth(10, canvas.width); }
                if (e.key === 's' || e.key === 'S') { paddle.changeWidth(-10, canvas.width); }
            }
            if (e.key === 'Enter') handleInteraction();
            if (e.code === 'Space') {
                if (gameState === 'playing') gameState = 'paused';
                else handleInteraction();
                e.preventDefault();
            }
            if (e.key in keyStatus) { keyStatus[e.key] = true; e.preventDefault(); }
        });
        window.addEventListener('keyup', e => { if (e.key in keyStatus) keyStatus[e.key] = false; });
        window.addEventListener('mousedown', () => { handleInteraction(); });
        window.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('main-canvas'); ctx = canvas.getContext('2d');
            screenArea = { left: 0, top: 0, right: canvas.width, bottom: canvas.height };
            mainLoop();
        });
    </script>
</body>
</html>